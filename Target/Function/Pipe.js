var n=async(...[t,{Accomplished:o,Changed:r,Failed:f,Fulfilled:u,Passed:s,Read:O,Wrote:p}])=>{for(const[e,a]of t.Results){t.On.Input=a,t.On.Output=e;try{if(t.On.Before=(await w(t.On.Input)).size,O&&p){if(t.On.Buffer=await O(t.On),t.On.Buffer=await p(t.On),!t.On.Buffer)continue;if(s&&await s(t.On)){try{await(await import("fs/promises")).access(c(t.On.Output),(await import("fs/promises")).constants.W_OK)}catch{await(await import("fs/promises")).mkdir(c(t.On.Output),{recursive:!0})}await(await import("fs/promises")).writeFile(t.On.Output,t.On.Buffer,"utf-8"),t.On.After=(await w(t.On.Output)).size,t.Logger>0&&(t.File++,r&&(t=await r(t))),t.Logger>1&&typeof o=="function"&&console.log(await o(t.On))}}}catch(i){t.Results.delete(t.On.Output),t.Logger>1&&console.log(typeof f=="function"?await f(t.On,i):i)}}if(t.Logger>0&&t.Results.size>0&&typeof u=="function"){const e=await u(t);e&&e.length>0&&console.log(e)}return t};const{dirname:c}=await import("path"),{stat:w}=await import("fs/promises");export{n as default,c as dirname,w as stat};
